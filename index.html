<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>巴哈姆特 動畫瘋 分析圖表</title>
    </head>
    <body>
        <div id="main">
            <div class="bg-blue-50 rounded-lg w-screen py-2 my-5">
                <div>
                    <select id="sort-selector" class="w-30 m-2 rounded bg-blue-200 text-right">
                        <option value="view_avg">集均觀看數</option>
                        <option value="view">總觀看數</option>
                        <option value="score">評分</option>
                        <option value="year">作品年份</option>
                    </select>
                    <select id="selector" class="w-24 m-2 rounded bg-blue-200 text-right"></select>
                    <input id="from_number" class="w-16 m-2 rounded bg-blue-200 text-right" type="number" value="1" />
                    <input id="to_number" class="w-16 m-2 rounded bg-blue-200 text-right" type="number" value="10000" />
                </div>
                <div id="chart" class="w-11/12 h-96 mx-4"></div>
            </div>
            <div class="bg-indigo-50 rounded-lg w-screen py-2 my-5">
                <div>
                    <select id="anime-selector" class="w-96 px-2 m-2 rounded bg-indigo-200 text-right"></select>
                </div>
                <div id="details-chart" class="w-11/12 h-96 mx-4"></div>
            </div>
            <div id="extra-info" class="py-5 mx-2"></div>
        </div>
        <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet" />
        <style>
            * {
                position: relative;
                font-family: sans-serif;
            }
            html,
            body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #main {
                width: 100%;
                height: 100%;
            }

            select {
                text-align-last: right;
            }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js"></script>
        <script>
            const color = {
                奇幻冒險: "#0388ff",
                戀愛: "#ff3f9a",
                幽默搞笑: "#639300",
                青春校園: "#00ab75",
                科幻未來: "#00a1bb",
                靈異神怪: "#b77a00",
                運動競技: "#00ac22",
                料理美食: "#7a72ff",
                其他: "#c55aff",
                溫馨: "#ff46d8",
                推理懸疑: "#00a400",
                社會寫實: "#f46000",
                歷史傳記: "#ff484f",
            };

            class Overview {
                constructor(data) {
                    /* 資料處理 */
                    this.data = data;
                    this.types = [...new Set(data.map((x) => x.type))];
                    this.types.unshift("All");

                    /* 物件定義 */
                    this.chart = echarts.init(document.querySelector("#chart"));
                    this.sort_selector = document.querySelector("#sort-selector");
                    this.selector = document.querySelector("#selector");
                    this.from = document.querySelector("#from_number");
                    this.to = document.querySelector("#to_number");
                    this.anime_selector = document.querySelector("#anime-selector");
                    this.details_chart = echarts.init(document.querySelector("#details-chart"));

                    /* 初始設定更新 */
                    this.create_selector();
                    this.set_listener();
                    this.read_search_param();
                    this.update_chart();
                    this.set_details_chart();

                    /* Chart 事件監聽 */
                    this.chart.on("click", "series", (e) => {
                        let anime = this.data.filter((x) => x.name === e.name)[0];
                        console.log(anime);
                        this.anime_selector.value = anime.name;
                        this.set_details_chart();
                    });
                }

                static async create() {
                    let data = await get_latest_data();
                    return new Overview(data);
                }

                sort_data(mode = "view_avg") {
                    switch (mode) {
                        case "view_avg":
                            this.data.sort((a, b) => b.view_avg - a.view_avg);
                            this.sort_mode = "集均觀看數";
                            this.sort = "view_avg";
                            break;
                        case "view":
                            this.data.sort((a, b) => b.view - a.view);
                            this.sort_mode = "總觀看數";
                            this.sort = "view";
                            break;
                        case "score":
                            this.data.sort((a, b) => {
                                return b.vote.score - a.vote.score || b.vote.voter - a.vote.voter;
                            });
                            this.sort_mode = "評分";
                            this.sort = "vote.score";
                            break;
                        case "year":
                            this.data.sort((a, b) => {
                                return b.year - a.year || b.month - a.month;
                            });
                            this.sort_mode = "作品年份";
                            this.sort = "year";
                            break;
                        default:
                            break;
                    }
                }

                set_chart({ type, data }) {
                    console.log(`類別：${type} - 總共有 ${data.length} 筆資料`);
                    let option = {
                        title: {
                            text: type,
                        },
                        tooltip: {},
                        legend: {
                            data: [...new Set(data.map((x) => x.type))],
                        },
                        xAxis: {
                            data: data.map((x) => x.name),
                        },
                        yAxis: {},
                        series: [
                            {
                                name: this.sort_mode,
                                type: "bar",
                                data: data.map((x) => {
                                    return {
                                        value: x.find_deep(this.sort).toFixed(1),
                                        itemStyle: {
                                            color: color[x.type],
                                        },
                                    };
                                }),
                            },
                        ],
                    };

                    this.chart.setOption(option);
                }

                create_selector() {
                    this.types.forEach((t) => {
                        let option = document.createElement("option");
                        option.innerHTML = option.value = t;
                        this.selector.appendChild(option);
                    });

                    this.data
                        .map((x) => x.name)
                        .forEach((n) => {
                            let option = document.createElement("option");
                            option.innerHTML = option.value = n;
                            this.anime_selector.appendChild(option);
                        });
                }

                set_listener() {
                    this.sort_selector.addEventListener("change", (e) => {
                        this.update_chart();
                    });

                    this.selector.addEventListener("change", (e) => {
                        this.update_chart();
                    });

                    this.from.addEventListener("change", (e) => {
                        this.update_chart();
                    });

                    this.to.addEventListener("change", (e) => {
                        this.update_chart();
                    });

                    this.anime_selector.addEventListener("change", (e) => {
                        this.set_details_chart(this.anime_selector.value);
                    });
                }

                update_chart() {
                    update_search_param({
                        sort: this.sort_selector.value,
                        type: this.selector.value,
                        from: this.from.value,
                        to: this.to.value,
                        anime: this.anime_selector.value,
                    });
                    this.sort_data(this.sort_selector.value);
                    if (this.selector.value === "All") this.set_chart({ type: "All", data: this.data.slice(this.from.value - 1, this.to.value) });
                    else
                        this.set_chart({
                            type: this.selector.value,
                            data: this.data.filter((x) => x.type === this.selector.value).slice(this.from.value - 1, this.to.value),
                        });
                }

                read_search_param() {
                    let sp = new URLSearchParams(location.search);
                    if (sp.get("sort") !== null) this.sort_selector.value = sp.get("sort");
                    if (sp.get("type") !== null) this.selector.value = sp.get("type");
                    if (sp.get("from") !== null) this.from.value = sp.get("from");
                    if (sp.get("to") !== null) this.to.value = sp.get("to");
                    if (sp.get("anime") !== null) this.anime_selector.value = sp.get("anime");
                }

                set_details_chart() {
                    let name = this.anime_selector.value;
                    let anime = this.data.filter((x) => x.name.includes(name))[0];
                    if (!anime) return null;

                    update_search_param({
                        sort: this.sort_selector.value,
                        type: this.selector.value,
                        from: this.from.value,
                        to: this.to.value,
                        anime: this.anime_selector.value,
                    });

                    let option = {
                        title: {
                            text: anime.name,
                        },
                        tooltip: {},
                        legend: {
                            data: Object.values(anime.details),
                        },
                        xAxis: {
                            data: Object.keys(anime.details),
                        },
                        yAxis: {
                            type: "value",
                        },
                        series: [
                            {
                                data: Object.values(anime.details),
                                type: "line",
                                symbol: "circle",
                                symbolSize: 6,
                            },
                        ],
                        color: color[anime.type],
                    };

                    this.details_chart.setOption(option);
                }
            }

            let show = Overview.create();

            async function get_latest_data() {
                let meta = await fetch("https://raw.githubusercontent.com/JacobLinCool/Bahamut-Anime-Analytics/data/meta.json").then((res) => res.json());
                console.log(`最新資料：${meta.latest[0]}/${meta.latest[1]}/${meta.latest[2]}`);
                document.querySelector("#extra-info").innerHTML += `最新資料：${meta.latest[0]}/${meta.latest[1]}/${meta.latest[2]}`;
                return await fetch(
                    `https://raw.githubusercontent.com/JacobLinCool/Bahamut-Anime-Analytics/data/${meta.latest[0]}/${meta.latest[1]}/${meta.latest[2]}/Full/all.json`
                ).then((res) => res.json());
            }

            function update_search_param(pm) {
                let sp = new URLSearchParams();
                Object.entries(pm).forEach((pair) => {
                    sp.append(...pair);
                });
                history.pushState(pm, "", "?" + sp.toString());
            }

            Object.prototype.find_deep = function (path) {
                let dist = this;
                path.split(".").forEach((key) => {
                    dist = dist ? dist[key] : undefined;
                });
                return dist;
            };
        </script>
    </body>
</html>
